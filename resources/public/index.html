<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/basscss.css" rel="stylesheet" type="text/css">
    <link href="css/codemirror.css" rel="stylesheet" type="text/css">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link href="css/monokai.css" rel="stylesheet" type="text/css">
    <link href="//cloud.webtype.com/css/fc0c09ce-40cc-4860-8ebe-67ff343dedda.css" rel="stylesheet" type="text/css" />
  </head>
  <body class="container">
    <header>
      <h1>Into the Land of Quil</h1>
      <h2>A Great and Valiant Journey of Derring-do</h2>
    </header>

    <div id="content">

      <div>
        <p><em>
          Good day, traveler. Today you embark upon a journey into Quil. May your
          sight be keen, for there are sights to behold.
        </em></p>
        <p>
          This is a tutorial
          for <a href="https://github.com/quil/quil">Quil</a>,
          a visual programming system that combines the powers
          of <a href="http://clojure.org/clojurescript">ClojureScript</a>
          and <a href="http://processingjs.org/">Processing.js</a>.
        </p>
        <p>
          Quil lets you do visual programming. You can even create drawings and
          animations that interact using the keyboard and the mouse.
        </p>
        <p>
          A Quil program is called a sketch. The <em>draw function</em> lies at
          the core of the sketch and does the work of actually drawing the
          visuals.
        </p>
        <p>
          You'll find many sketches in this tutorial. All of them are "live",
          change the code and you should immediately see the sketch change.
          Hover over a Quil function name to see what it does.
        </p>

        <h2>A Taste of Quil</h2>
        <p>
          These first few sketches will give you a taste of things to come. They
          are presented without much explanation. We'll dive into the details
          later. Play around with them, there's nothing you can break. Should you happen to make a mess, simply hit the red "revert" button, and you'll get the original code back.
        </p>

        <h3>The Pine Forest</h3>
        </p>
          The road to Quil starts in the Pine Forest. Try changing some numbers
          and see what happens!
        </p>

        <!-- <script type="cljs" class="editor" data-cmid="test" data-monoline="true"> -->
        <!--   (+ 2 2) -->
        <!-- </script> -->


        <script type="cljs" class="editor" data-cmid="pine-forest">
;; This is the draw function which Quil will run
(defn draw-pine-forest []
  ;; First we set the stage: a background color, and no borders around shapes
  (background 20 200 151)
  (no-stroke)

  ;; Set a fill color for shapes. The numbers correspond with
  ;; red - green - blue, and go up to 255
  (fill 34 95 215)

  ;; Fill the width and height of the canvas with pine-forest
  (doseq [x (range 0 (width) 50)
          y (range 0 (height) 60)]
    (triangle (+ x 25) y
              x (+ y 50)
              (+ x 50) (+ y 50))
    (rect (+ x 16) (+ y 50) 16 10)))

(sketch
  :host "pine-forest"
  :size [300 300]
  :draw #'draw-pine-forest
  :setup #(frame-rate 1))
        </script>

        <p>
          That's already a lovely pattern we've got going. Knit it into a
          turtleneck and aunt Juliet will envy you forever. But there's more.
          How about we get things moving?
        </p>

        <h3>The Carousel</h3>
        <p>
          Time to make your head spin! This is an example of an animation. Think
          of it like an old fashioned film projector, spinning through a
          sequence of images. Quil calls your draw function many times in rapid
          succession to draw the individual images, called <em>frames</em>.
        </p>
        <p>
          Quil keeps a count of how many frames have passed. This sketch uses
          that <tt>frame-count</tt> to determine the position of the circle.
        </p>
        <script type="cljs" class="editor" data-cmid="carousel">
(defn draw-carousel []
  (background 255)
  (no-stroke)
  (fill 252 90 44)

  (let [radians (/ (frame-count) 20)
        x (+ 150 (* 100 (cos radians)))
        y (+ 150 (* 100 (sin radians)))
        width 30
        height 30]
      (ellipse x y, width height)))

(sketch
  :host "carousel"
  :size [300 300]
  :draw #'draw-carousel)
        </script>

        <h3>Paint Blotches</h3>

        <p>
          Quil also lets you interact with the keyboard and mouse. Move your mouse
          over the canvas to smear it with thick blotches of paint that run down
          the canvas.
        </p>

        <p>
          This is an example of a sketch that has <em>state</em>. This means
          that how it looks depends on its history, in this case, the past
          positions of the mouse.
        </p>

        <script type="cljs" class="editor" data-cmid="paint-blotch">
(def colors [[249 202 216]
             [232 181 188]
             [240 155 150]
             [209 188 219]
             [204 199 241]
             [198 221 245]
             [202 216 247]])

(defn- move-dots-down [state]
  (->> state
    (map #(update-in % [:pos 1] inc))
    (filter #(< (get-in % [:pos 1]) (height)))))

(defn paint-blotch-update
  "For each update cycle, register the new mouse position,
  then move all dots down"
  [state]
  (move-dots-down
    (let [x (mouse-x) y (mouse-y)]
      (if (and (> x 0) (> y 0) (< x (width)) (< y (height)))
        (conj state {:pos [x y] :color (rand-nth colors)})
        state))))

(defn paint-blotch-draw [state]
  (stroke-weight 25)
  (doseq [{[x1 y1] :pos color :color} state]
    (apply stroke color)
    (point x1 y1)))

(defn paint-blotch-setup []
  (background 255)
  (fill 0)
  (text "paint me!" 120 145)
  ;; The initial state is just an empty list
  (list))

(sketch
  :host "paint-blotch"
  :size [300 300]
  :setup #'paint-blotch-setup
  :update #'paint-blotch-update
  :draw #'paint-blotch-draw
  :middleware [quil.middleware/fun-mode])
                </script>

        <h2>Creating a sketch</h2>

        <p>
          To get Quil to draw something on the screen, you need a <tt>:draw</tt>
          function. You pass this function on to Quil when you call <tt>(sketch
          ,,,)</tt>. Quil accepts other functions as well, like
          a <tt>:setup</tt> function, which is called once when your sketch
          starts to run.
        </p>
        <p>
          The <tt>:host</tt> is the HTML <tt>id</tt> of the canvas element,
          which is where Quil will draw your sketch. In this tutorial, we have
          already set up a canvas for you, so no need to worry about that.
        </p>

        <h2>The Quil API</h2>

        <p>
          Inside the <tt>:draw</tt> function you have access to a long list of functions
          provided by Quil. Keep the <a href="http://quil.info/api/">Quil API
          reference</a> close to you at all times. Hang it above your bed, keep
          it under your pillow. It's a magical toolbox providing endless
          opportunities for your creations.
        </p>

        <h2>Drawing shapes</h2>

        <p>
          When you draw a shape, it stays on the canvas until you draw
          something on top of it. You can see this well in the last example.
          <tt>(background r g b)</tt> will refill the whole canvas with a solid
          color, so you can use it in your draw function to clear the canvas
          before drawing the new frame. Replace <t>r</t>, <t>g</t> and <t>b</t>
          by integers between 0 and 255 that represents red, green and blue
          components in
          the <a href="https://en.wikipedia.org/wiki/RGB_color_space">RGB</a>
          color space. Try and see how the colors change as you modify the three
          nubmers!
</p>

<p>
  One of the easiest things you can draw is a rectangle. Quil's <tt>rect</tt>
  function takes four parameters, <tt>x</tt>, <tt>y</tt>, <tt>width</tt>
  and <tt>height</tt>. The first two arguments represent the location of the top
  left corner of rectangle on the canvas. Remember that in Quil, as in computer
  graphics in general, the origin <tt>(0, 0)</tt> of the coordinate system represents
  the top left corner of the drawing surface. In this example, we're drawing a
  centered equilateral rectangle or square.
</p>

<script type="cljs" class="editor" data-cmid="rect">
(defn draw-rect []
  (background 20 200 151)
  (no-stroke)
  (fill 34 95 215)

  (rect 50 50 200 200))

(sketch
  :host "rect"
  :size [300 300]
  :draw #'draw-rect
  :setup #(frame-rate 1))
</script>

<p>
  Drawing a circle isn't any harder. While Quil does not come with a
  special function for drawing circles, it supplies a function for the general
  case of drawing ovals (or ellipses). That will work well — after all, a
  circle is just an ellipse with equal horizontal and vertical dimensions.
  The <tt>ellipse</tt> function takes the same arguments
  as <tt>rect</tt>: <tt>x</tt>, <tt>y</tt>, <tt>width</tt> and <tt>height</tt>.
  However, whereas in the case of <tt>rect</tt> the point <tt>(x,y)</tt>
  reprents the top-left corner of the figure, in <tt>ellipse</tt> it represents
  its center. This decision of Quil's authors makes sense: an ellipse doesn't
  have corners.
</p>

<script type="cljs" class="editor" data-cmid="circle">
(defn draw-circle []
  (background 20 200 151)
  (no-stroke)
  (fill 34 95 215)

  (ellipse 150 150 200 200))

(sketch
  :host "circle"
  :size [300 300]
  :draw #'draw-circle
  :setup #(frame-rate 1))
</script>

        <h2>Animation and State</h2>



        <h2>Advanced Examples</h2>

        <p>
          These examples are taken from the Quil site. Can you find out how they work?
        </p>

        <h3><a href="https://github.com/quil/quil-site/blob/master/src/cljs/quil_site/examples/tailspin.cljs">Tailspin by Erik Svedäng</a></h3>
<script type="cljs" class="editor" data-cmid="tailspin">
(defn setup []
  (frame-rate 30)
  (let [max-r (/ (width) 2)
        n (int (map-range (width)
                            200 500
                            20 50))]
   {:dots (into [] (for [r (map #(* max-r %)
                                (range 0 1 (/ n)))]
                     [r 0]))}))

(def speed 0.0003)

(defn move [dot]
  (let [[r a] dot]
    [r (+ a (* r speed))]))

(defn update-state [state]
  (update-in state [:dots] #(map move %)))

(defn dot->coord [[r a]]
  [(+ (/ (width) 2) (* r (cos a)))
   (+ (/ (height) 2) (* r (sin a)))])

(defn draw-state [state]
  (background 255)
  (fill 0)
  (let [dots (:dots state)]
    (loop [curr (first dots)
           tail (rest dots)
           prev nil]
      (let [[x y] (dot->coord curr)]
        (ellipse x y 5 5)
        (when prev
          (let [[x2 y2] (dot->coord prev)]
            (line x y x2 y2))))
      (when (seq tail)
        (recur (first tail)
               (rest tail)
               curr)))))

(sketch
  :host "tailspin"
  :size [500 500]
  :setup #'setup
  :update #'update-state
  :draw #'draw-state
  :middleware [quil.middleware/fun-mode])
        </script>

      </div>


    <div id="tooltip"></div>
    <script src="js/oneline.js" type="text/javascript"></script>
    <script src="js/compiled/clojure_cup_2015.js" type="text/javascript"></script>
  </body>
</html>
