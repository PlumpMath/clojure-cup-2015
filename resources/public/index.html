<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/basscss.css" rel="stylesheet" type="text/css">
    <link href="css/codemirror.css" rel="stylesheet" type="text/css">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link href="css/monokai.css" rel="stylesheet" type="text/css">
    <link href="//cloud.webtype.com/css/fc0c09ce-40cc-4860-8ebe-67ff343dedda.css" rel="stylesheet" type="text/css" />
  </head>
  <body class="container">
    <header>
      <h1>Into the Land of Quil</h1>
      <h2>A Great and Valiant Journey of Derring-do</h2>
    </header>

    <div id="content">

      <div>
        <p><em>
          Goodday, traveler. Today you embark upon a journey into Quil. May your
          sight be keen, for there are sights to behold.
        </em></p>
        <p>
          This is a tutorial for Quil, a visual programming system that combines
          the powers of ClojureScript and Processing.js.
        </p>
        <p>
          Quil lets you do visual programming. You can make drawings and
          animations, even interactive ones with keyboard and mouse.
        </p>
        <p>
          A Quil program is called a sketch. You set up a <em>draw function</em> to
          draw the actual visuals.
        </p>
        <p>
          The road to Quil first goes through the Pine Forest. Try changing some
          numbers and see what happens!
        </p>

        <script type="cljs" class="editor" data-cmid="pine-forest">
;; This is the draw function which Quil will run
(defn draw-pine-forest []
  ;; First we set the stage: a background color, and no borders around shapes
  (background 20 200 151)
  (no-stroke)

  ;; Set a fill color for shapes. The numbers correspond with
  ;; red - green - blue, and go up to 255
  (fill 34 95 215)

  ;; Fill the width and height of the canvas with pine-forest
  (doseq [x (range 0 (width) 50)
          y (range 0 (height) 60)]
    (triangle (+ x 25) y
              x (+ y 50)
              (+ x 50) (+ y 50))
    (rect (+ x 16) (+ y 50) 16 10)))

(sketch
  :host "pine-forest"
  :size [300 300]
  :draw #'draw-pine-forest
  :setup #(frame-rate 1))
        </script>

        <p>
          That's already a lovely pattern we got going. Knit it into a
          turtleneck and aunt Juliet will envy you forever. But there's more,
          how about we get things moving a bit?
        </p>
        <p>
          This is the simplest version of an animation. It uses the current
          `frame-count` to determine the position of the circle.
        </p>

        <script type="cljs" class="editor" data-cmid="carousel">
(defn draw-carousel []
  (background 255)
  (no-stroke)
  (fill 252 90 44)

  (let [radians (/ (frame-count) 20)
        x (+ 150 (* 100 (cos radians)))
        y (+ 150 (* 100 (sin radians)))
        width 30
        height 30]
      (ellipse x y, width height)))

(sketch
  :host "carousel"
  :size [300 300]
  :draw #'draw-carousel)
        </script>

        <p>
          Quil also lets you interact with keyboard and mouse. Try moving your
          mouse over the canvas, and you should see circles appear. This is an
          example of a sketch that has <em>state</em>. This means that how it
          looks depends on its history, in this case, the past positions of the
          mouse.
        </p>

        <script type="cljs" class="editor" data-cmid="paint-blotch">
(def colors [[249 202 216]
             [232 181 188]
             [240 155 150]
             [209 188 219]
             [204 199 241]
             [198 221 245]
             [202 216 247]])

(defn- move-dots-down [state]
  (->> state
    (map #(update-in % [:pos 1] inc))
    (filter #(< (get-in % [:pos 1]) (height)))))

(defn paint-blotch-update
  "For each update cycle, register the new mouse position,
  then move all dots down"
  [state]
  (move-dots-down
    (let [x (mouse-x) y (mouse-y)]
      (if (and (> x 0) (> y 0) (< x (width)) (< y (height)))
        (conj state {:pos [x y] :color (rand-nth colors)})
        state))))

(defn paint-blotch-draw [state]
  (stroke-weight 25)
  (doseq [{[x1 y1] :pos color :color} state]
    (apply stroke color)
    (point x1 y1)))

(defn paint-blotch-setup []
  (background 255)
  ;; The initial state is just an empty list
  (list))

(sketch
  :host "paint-blotch"
  :size [300 300]
  :setup #'paint-blotch-setup
  :update #'paint-blotch-update
  :draw #'paint-blotch-draw
  :middleware [quil.middleware/fun-mode])
                </script>

        <h2>Creating a sketch</h2>

        <p>
          To get Quil do draw something, the minimum you need is
          a <tt>:draw</tt> function. You then pass this on to Quil when you
          call <tt>(sketch ,,,)</tt>. Quil can take other functions as well,
          like a <tt>:setup</tt> function, which is called once when your sketch
          starts to run.
        </p>
        <p>
          The <tt>:host</tt> is the HTML "id" of the canvas
          element where Quil will draw your sketch. We already set up a canvas
          for you, so no need to worry about that.
        </p>

        <h2>The Quil API</h2>

        <p>
          Inside the <tt>:draw</tt> you have access to a long list of functions
          provided by Quil. You already used many of them, they let you
        </p>
        <p>
          draw shapes :
        </p>
        <ul>
          <li><tt>(triangle x1 y1, x2 y2, x3 y3)</tt></li>
          <li><tt>(rect x1 y1, x2 y2)</tt></li>
          <li><tt>(ellipse x1 y1, width, height)</tt></li>
          <li><tt>(point x1 y1)</tt></li>
          <li><tt>(background red green blue)</tt></li>
        </ul>
        <p>
          manipulate the drawing context:
        </p>
        <ul>
          <li><tt>(fill red green blue)</tt></li>
          <li><tt>(stroke red green blue)</tt></li>
          <li><tt>(stroke-weight weight)</tt></li>
          <li><tt>(no-stroke)</tt></li>
        </ul>

        <p>
          inspect or change the state of Quil:
        </p>
        <ul>
          <li><tt>(width)</tt></li>
          <li><tt>(height)</tt></li>
          <li><tt>(frame-count)</tt></li>
          <li><tt>(frame-rate r)</tt></li>
        </ul>

        <p>
          interact with mouse or keyboard
        </p>

        <ul>
          <li><tt>(mouse-x)</tt></li>
          <li><tt>(mouse-y)</tt></li>
        </ul>

        <p>
          Keep the <a href="http://quil.info/api/">Quil API reference</a> close
          to you at all times. Hang it above your bed, keep it under your
          pillow. It's a magical toolbox providing endless opportunities for
          your creations.
        </p>

        <h2>Drawing shapes</h2>



        <p>
          When you draw a shape, it stays there until you draw something on top
          of it. You can see this well in the last example.
          <tt>(background ,,,)</tt> will refill the whole canvas with a solid
          color, so you can use it in your draw function to clear the canvas
          before drawing the new frame.
        </p>

        <h2>Advanced Examples</h2>

        <p>
          These examples are taken from the Quil site. Can you find out how they work?
        </p>

        <h3>Tailspin by Erik Sved√§ng</h3>

        <script type="cljs" class="editor" data-cmid="tailspin">
(defn setup []
  (frame-rate 30)
  (let [max-r (/ (width) 2)
        n (int (map-range (width)
                            200 500
                            20 50))]
   {:dots (into [] (for [r (map #(* max-r %)
                                (range 0 1 (/ n)))]
                     [r 0]))}))

(def speed 0.0003)

(defn move [dot]
  (let [[r a] dot]
    [r (+ a (* r speed))]))

(defn update-state [state]
  (update-in state [:dots] #(map move %)))

(defn dot->coord [[r a]]
  [(+ (/ (width) 2) (* r (cos a)))
   (+ (/ (height) 2) (* r (sin a)))])

(defn draw-state [state]
  (background 255)
  (fill 0)
  (let [dots (:dots state)]
    (loop [curr (first dots)
           tail (rest dots)
           prev nil]
      (let [[x y] (dot->coord curr)]
        (ellipse x y 5 5)
        (when prev
          (let [[x2 y2] (dot->coord prev)]
            (line x y x2 y2))))
      (when (seq tail)
        (recur (first tail)
               (rest tail)
               curr)))))

(sketch
  :host "tailspin"
  :size [500 500]
  :setup #'setup
  :update #'update-state
  :draw #'draw-state
  :middleware [quil.middleware/fun-mode])
        </script>

      </div>

    <script src="js/compiled/clojure_cup_2015.js" type="text/javascript"></script>
    <script src="js/oneline.js" type="text/javascript"></script>
  </body>
</html>
