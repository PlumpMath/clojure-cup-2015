<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/basscss.css" rel="stylesheet" type="text/css">
    <link href="css/codemirror.css" rel="stylesheet" type="text/css">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link href="css/monokai.css" rel="stylesheet" type="text/css">
    <link href="//cloud.webtype.com/css/fc0c09ce-40cc-4860-8ebe-67ff343dedda.css" rel="stylesheet" type="text/css" />
  </head>
  <body class="container">
    <header>
      <h1>Intro to Clojure</h1>
      <h2>A short intro to Clojure, many thanks to Clojure Bridge for the most of the material.</h2>
    </header>
    <div id="content">
      <p>
        Notice the parentheses. Parentheses enclose instructions to the computer in Clojure. A left parenthesis is the start of the instruction, and a matching right parenthesis is the end of enclosing instruction. Normally, Clojure code has a lot of nested parentheses, on other words, nested enclosing instructions.
      </p>
      <p>
        Next to the parentheses, we see the instructions to the computer. That instruction is normally what we call a function. The functions do all the hard work in Clojure. print-str, + and forward are all functions. When these functions get run, they return a some type of value. Clojure functions always return a value.
      </p>
      <h3>
        Simple Values
      </h3>
      <h4>
        Strings
      </h4>
      <p>What is a string? A string is just a piece of text. To make a string, you enclose it in quotation marks. Look at the last example. A backslash is how we put a quotation mark inside a string. Do not try using single quotes to make a string.
        <ul>
          "Hello, World!"
        </ul>
        <ul>
          "Aubrey said, \"I think we should go to the Orange Julius.\""
        </ul>
      </p>
      <h4>
        Booleans and nil
      </h4>
      <p>
        A boolean is a true or false value, and you type them just like that, true and false. Often in programming, we need to ask a true or false question, like “Is this class in the current semester?” or “Is this person’s birthday today?” When we ask those questions, we get a boolean back.
        There is another value nil, which behaves like a boolean in terms of truthiness. But, nil means no value at all and not a boolean
        <ul>
          true
        </ul>
        <ul>
          false
        </ul>
        <ul>
          nil
        </ul>
      </p>
      <h4>
        Keywords
      </h4>
      <p>
        Keywords are the strangest of the basic value types. Some computer languages have similar one. However, keywords don’t have a real world analog like numbers, strings, or booleans. You can think of them as a special type of string, one that’s used for labels. They are often used as keys of key-value pair for maps (data structure; will learn later).
        <ul>
          :trinity
        </ul>
        <ul>
          :first
        </ul>
        <ul>
          :last
        </ul>
      </p>
      <h4>
        Numbers
      </h4>
      <p>
        Clojure has several different types of numbers.
        First up are integers. Integers include zero, the positive whole numbers, and the negative whole numbers, and you write them just like we write them normally.
        <ul>
          0, 12, -42
        </ul>
        Then we have decimal numbers, which are also called floats. They include any numbers that have a decimal point in them.
        <ul>
          0.0000072725, 10.5, -99.9
        </ul>
        Finally, we have fractions, which are also called ratios. Computers cannot perfectly represent all floats, but ratios are always exact. We write them with a slash, like so:
        Note that, just like with pen-and-paper math, the denominator of your ratio cannot be equal to 0.
        <ul>
          1/2, -7/3
        </ul>
      </p>
      <h3>
        Infix vs. prefix notation
      </h3>
      <p>
        In Clojure, +, -, * and / appear before two numbers. This is called prefx
        notation. What you’re used to seeing is called infx notation, as the arithmetic 
        operator is in-between the two operands.
      </p>
      <script type="cljs" class="editor" data-cmid="exp-precedence" data-monoline="true">
        (* 100 100)
      </script>
      <h4>
        Explicit precedence
      </h4>
      <p>
        Imagine both are unclear, but notice that in the prefix version, you do not have to ever think about the precedence of operators. Because each expression has the operator before all the operands and the entire expression is wrapped in parentheses, all precendence is explicit.
      </p>
      <p>
        Infix: 1 + 2 / 3
        See how this is written in Clojure in the editor below.
        This example uses integers but try changing the numbers to floats, decimals, or fractions and see wha
      </p>
      <script type="cljs" class="editor" data-cmid="exp-precedence" data-monoline="true">
        (+ 1 (/ 2 3))
      </script>
      <h4>
        Less repetitive
      </h4>
      <p>
        Another reason prefix notation can be nice is that it can make long expressions less repetitive. With prefix notation, if we plan to use the same operator on many operands, we do not have to repeat the operator between them.
      </p>
      <p>
        Infix: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9
        See how this is written in Clojure in the editor below
      </p>
      <script type="cljs" class="editor" data-cmid="exp-precedence" data-monoline="true">
        (+ 1 2 3 4 5 6 7 8 9)
      </script>
      <h3>
        Some basic Clojure functions
      </h3>
      <p>
        <strong>Type</strong> try evaluating type on a few different values that we covered. 
      </p>
      <script type="cljs" class="editor" data-cmid="exp-precedence" data-monoline="true">
        (type :hello)
      </script>
      <p>
        <strong>str</strong> this combines two strings, but try changing one of them to a number. 
      </p>
      <script type="cljs" class="editor" data-cmid="exp-precedence" data-monoline="true">
        (str "hey " "there")
      </script>
      <p>
        <strong>inc</strong> this combines two strings, but try changing one of them to a number. 
      </p>
      <script type="cljs" class="editor" data-cmid="exp-precedence" data-monoline="true">
        (inc 5)
      </script>
      <p>
        <strong>=</strong> returns a boolean after evaluating whether the arguments are equivalent. Works on all data types not just numbers. Try changing the arguments and nesting other functions.
      </p>
      <script type="cljs" class="editor" data-cmid="exp-precedence" data-monoline="true">
        (= 3 5)
      </script>
       <p>
        <strong>concat</strong>
      </p>
      <script type="cljs" class="editor" data-cmid="exp-precedence" data-monoline="true">
        (concat "Bobby" "Stacy" "Phillip")
      </script>
      
    </div>
    <script src="js/oneline.js" type="text/javascript"></script>
    <script src="js/compiled/clojure_cup_2015.js" type="text/javascript"></script>
  </body>
</html>
