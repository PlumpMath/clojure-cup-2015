<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/basscss.css" rel="stylesheet" type="text/css">
    <link href="css/codemirror.css" rel="stylesheet" type="text/css">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link href="css/monokai.css" rel="stylesheet" type="text/css">
    <link href="//cloud.webtype.com/css/fc0c09ce-40cc-4860-8ebe-67ff343dedda.css" rel="stylesheet" type="text/css" />
  </head>
  <body class="container">
    <header>
      <h1>Intro to Clojure</h1>
      <h2>A short intro to Clojure, many thanks to <a href="http://www.clojurebridge.org/">Clojure Bridge</a> for most of the material.</h2>
    </header>
    <div id="content">
      <p>
        Notice the parentheses. Parentheses enclose instructions to the computer
        in Clojure. A left parenthesis is the start of the instruction, and a
        matching right parenthesis is the end of the enclosing instruction. Clojure code has a lot of nested parentheses.
      </p>
      <img class="absolute" src="img/editme.svg" style="z-index: 4000;transform: translate(630px, -100px);pointer-events:none;"/>
      <script type="cljs" class="editor" data-cmid="exp1" data-monoline="true">
        (str "Hello," " World!")
      </script>
      <p>
        Next to the parentheses, we see the instructions to the computer. That instruction is normally what we call a function. The functions do all the hard work in Clojure. print-str, + and forward are all functions. When these functions get run, they return a some type of value. Clojure functions always return a value.
      </p>
      <h3>
        Simple Values
      </h3>
      <h4>
        Strings
      </h4>
      <p>What is a string? A string is just a piece of text. To make a string, you enclose it in quotation marks. Look at the last example. A backslash is how we put a quotation mark inside a string. Do not try using single quotes to make a string.
        <pre>
   "Hello, World!"
   "Aubrey said, \"I think we should go to the Orange Julius.\""
        </pre>
      </p>
      <h4>
        Booleans and nil
      </h4>
      <p>
        A boolean is a true or false value, and you type them just like that, true and false. Often in programming, we need to ask a true or false question, like “Is this class in the current semester?” or “Is this person’s birthday today?” When we ask those questions, we get a boolean back.
        There is another value nil, which behaves like a boolean in terms of truthiness. But, nil means no value at all and not a boolean
        <pre>
   true
   false
   nil
        </pre>
      </p>
      <h4>
        Keywords
      </h4>
      <p>
        Keywords are the strangest of the basic value types. Some computer languages have similar one. However, keywords don’t have a real world analog like numbers, strings, or booleans. You can think of them as a special type of string, one that’s used for labels. They are often used as keys of key-value pair for maps (data structure; will learn later).
        <pre>
   :trinity
   :first
   :last
        </pre>
      </p>
      <h4>
        Numbers
      </h4>
      <p>
        Clojure has several different types of numbers.
        First up are integers. Integers include zero, the positive whole numbers, and the negative whole numbers, and you write them just like we write them normally.
      </p>
      <pre>
   0, 12, -42
      </pre>
      <p>Then we have decimal numbers, which are also called floats. They include any numbers that have a decimal point in them.
      </p>
      <pre>
   0.0000072725, 10.5, -99.9
      </pre>
      <p>Finally, we have fractions, which are also called ratios. Computers cannot perfectly represent all floats, but ratios are always exact. We write them with a slash, like so:
        Note that, just like with pen-and-paper math, the denominator of your ratio cannot be equal to 0.
        <pre>
   1/2, -7/3
        </pre>
      </p>
      <h3>
        Infix vs. prefix notation
      </h3>
      <p>
        In Clojure, +, -, * and / appear before two numbers. This is called prefx
        notation. What you’re used to seeing is called infx notation, as the arithmetic
        operator is in-between the two operands.
      </p>
      <script type="cljs" class="editor" data-cmid="exp2" data-monoline="true">
        (* 100 100)
      </script>
      <h4>
        Explicit precedence
      </h4>
      <p>
        Imagine both are unclear, but notice that in the prefix version, you do not have to ever think about the precedence of operators. Because each expression has the operator before all the operands and the entire expression is wrapped in parentheses, all precendence is explicit.
      </p>
      <p>
        This example uses integers but try changing the numbers to floats, decimals, or fractions and see what happens.
      </p>
      <p>
        See how this infix example is written in Clojure in the editor below. <br></br>
        Infix: 1 + 2 / 3
        </p>
      <script type="cljs" class="editor" data-cmid="exp3" data-monoline="true">
        (+ 1 (/ 2 3))
      </script>
      <h4>
        Less repetitive
      </h4>
      <p>
        Another reason prefix notation can be nice is that it can make long expressions less repetitive. With prefix notation, if we plan to use the same operator on many operands, we do not have to repeat the operator between them.
      </p>
      <p>
        See how this infix example is written in Clojure in the editor below <br></br>
        Infix: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9
      </p>
      <script type="cljs" class="editor" data-cmid="exp4" data-monoline="true">
        (+ 1 2 3 4 5 6 7 8 9)
      </script>
      <h3>
        Some basic Clojure functions
      </h3>
      <p>
        <strong>str</strong> this example combines two strings, but try changing one of them to a number.
      </p>
      <script type="cljs" class="editor" data-cmid="exp5" data-monoline="true">
        (str "Hey " "there")
      </script>
      <p>
        <strong>inc</strong>
      </p>
      <script type="cljs" class="editor" data-cmid="exp6" data-monoline="true">
        (inc 5)
      </script>
      <h3>
        Data Structures
      </h3>
      <p>
        So far, we’ve dealt with discrete pieces of data: one number, one string, one value. When programming, it is more often the case that you want to work with groups of data.
      </p>
      <h4>
        Vectors
      </h4>
      <p>
        A vector is a sequential collection of values. A vector may be empty. A vector may contain values of different types. Each value in a vector is numbered starting at 0, that number is called its index. The index is used to refer to each value when looking them up.
        <br>
        </br>
        Vectors are written using square brackets with any number of pieces of data inside them, separated by spaces. Here are some examples of vectors:
      </p>
      <p>
        The next two functions are used to make new vectors. The vector function takes any number of items and puts them in a new vector. conj is an interesting function that you’ll see used with all the data structures. With vectors, it takes a vector and an item and returns a new vector with that item added to the end of the vector. Why the name conj? conj is short for conjoin, which means to join or combine. This is what we’re doing: we’re joining the new item to the vector.
      </p>
      <script type="cljs" class="editor" data-cmid="exp7" data-monoline="true">
        (vector 5 10 15)
      </script>
      <script type="cljs" class="editor" data-cmid="exp8" data-monoline="true">
        (conj [5 10] 15)
      </script>
      <p>
        Now, take a look at these four functions.
      </p>
      <p>
        <strong>count</strong> gives us a count of the number of items in a vector.
      </p>
      <script type="cljs" class="editor" data-cmid="exp9" data-monoline="true">
        (count [5 10 15])
      </script>
      <p>
        <strong>nth</strong> gives us the nth item in the vector. Note that we start counting at 0, so in the example, calling nth with the number 1 gives us what we’d call the second element when we aren’t programming.
      </p>
      <script type="cljs" class="editor" data-cmid="exp10" data-monoline="true">
        (nth [5 10 15] 1)
      </script>
      <p>
        <strong>first</strong> returns the first item in the collection.
      </p>
      <script type="cljs" class="editor" data-cmid="exp11" data-monoline="true">
        (first [5 10 15])
      </script>
      <p>
        <strong>rest</strong> returns all except the first item.
      </p>
      <script type="cljs" class="editor" data-cmid="exp12" data-monoline="true">
        (rest [5 10 15])
      </script>
      <p>
        <strong>concat</strong>
      </p>
      <script type="cljs" class="editor" data-cmid="exp13" data-monoline="true">
        (concat ["Isabel" "Jordan"] ["Brisa"])
      </script>
      <h4>
        Maps
      </h4>
      <p>
        Maps hold a set of keys and values associated with them. You can think of it like a dictionary: you look up things using a word (a keyword) and see the definition (its value). If you’ve programmed in another language, you might have seen something like maps–maybe called dictionaries, hashes, or associative arrays.
      </p>
      <p>
        We write maps by enclosing alternating keys and values in curly braces, like so.
        {:first "Sally" :last "Brown"}
        Maps are useful because they can hold data in a way we normally think about it.
        Take our made up example, Sally Brown. A map can hold her first name and last name, her address, her favorite food,
        or anything else. It’s a simple way to collect that data and make it easy to look up.
        <br></br>
        This is an empty map. Add some key-value pairs!
      </p>
      <script type="cljs" class="editor" data-cmid="exp14" data-monoline="true">
        {}
      </script>
      <p>
        <strong>assoc</strong> and <strong>dissoc</strong> are paired functions: they associate and disassociate items from a map.
        See how we add the last name “Mitchell” to the map with assoc, and then we remove it with dissoc.
      </p>
      <script type="cljs" class="editor" data-cmid="exp15" data-monoline="true">
        (assoc {:first "Chelsey"} :last "Mitchell")
      </script>
      <script type="cljs" class="editor" data-cmid="exp16" data-monoline="true">
        (dissoc {:first "Chelsey" :last "Lucas"} :last)
      </script>
      <p>
        <strong>merge</strong> merges two maps together to make a new map.
      </p>
      <script type="cljs" class="editor" data-cmid="exp17" data-monoline="true">
        (merge {:first "Chelsey"} {:last "Mitchell"})
      </script>
      <p>
        <strong>count</strong> every collection has this function. Why do you think the answer is two? count is returning the number of associations.
      </p>
      <script type="cljs" class="editor" data-cmid="exp18" data-monoline="true">
        (count {:first "Chelsey" :last "Mitchell"})
      </script>
      <p>
        Since map is a key-value pair, the key is used to get a value from a map. One of the ways often used in Clojure is the examples below. We can use a keyword like using a function in order to look up values in a map. 
      </p>
      <script type="cljs" class="editor" data-cmid="exp19" data-monoline="true">
        (:first {:first "Chelsey" :last "Baptiste"})
      </script>
      <p>
        Then we have <strong>keys</strong> and <strong>vals</strong>, which are pretty simple: they return the keys and values in the map. The order is not guaranteed, so we could have gotten (:first :last) or (:last :first).
      </p>
      <script type="cljs" class="editor" data-cmid="exp20" data-monoline="true">
        (keys {:first "Chelsey" :last "Mitchell"})
      </script>
      <script type="cljs" class="editor" data-cmid="exp21" data-monoline="true">
        (vals {:first "Chelsey" :last "Mitchell"})
      </script>
      <p>
        Simple values such as numbers, keywords, and strings are not the only types of things you can put into collections. You can also put other collections into collections, so you can have a vector of maps, or a list of vectors, or whatever combination fits your data.
      </p>
      <p class="bold blue">
        <a href="index.html">Now you know how to do Clojure lets make some beautiful animation! Go to the Quil tutorial.&rarr;</a>
      </p>
      <sub>At the request of the survivors, the names have been changed. Out of respect for the dead,
        the rest has been told exactly as it occurred</sub>
    </div>
    <script src="js/oneline.js" type="text/javascript"></script>
    <script src="js/compiled/clojure_cup_2015.js" type="text/javascript"></script>
  </body>
</html>
